        -:    0:Source:roman_number_conversion.c
        -:    0:Graph:roman_number_conversion.gcno
        -:    0:Data:roman_number_conversion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    0:Source is newer than graph
        -:    1:// Função que converte números romanos para números inteiros.
        -:    2:
        -:    3:/**
        -:    4:
        -:    5:  \file
        -:    6:  \brief Arquivo que contém a função para converter números romanos
        -:    7:  em número inteiros, bem como as funções auxiliares neste processo.
        -:    8:
        -:    9:*/
        -:   10:
        -:   11:#include "roman_number_conversion.h"
        -:   12:
        -:   13:/** Função que converte números romanos. */
        -:   14:
       50:   15:int RomanNumberConversion (char *roman_number) {
        -:   16:
       50:   17:  char current_char, last_char = '\0', past_characters[30] = "";
        -:   18:  unsigned int iterator, last_char_count;
       50:   19:  int auxiliary_value, sum = 0;
        -:   20:
        -:   21:  // A função não aceita argumentos com mais de 30 caracteres.
        -:   22:
       50:   23:  if (strlen(roman_number) > 30)
        1:   24:    return -1;
        -:   25:
      253:   26:  for (iterator = 0; iterator < strlen(roman_number); iterator++) {
        -:   27:
        -:   28:    // Os caracteres são processados em caixa alta, evitando problemas.
        -:   29:
      214:   30:    current_char = toupper(roman_number[iterator]);
        -:   31:
      214:   32:    if(!ValidPrecedences(past_characters, current_char))
        8:   33:      return -1;
        -:   34:
        -:   35:    // Armazena-se o caracter atual.
        -:   36:
      206:   37:    past_characters[iterator] = current_char;
        -:   38:
      206:   39:    auxiliary_value = CharacterValue(current_char);
        -:   40:
        -:   41:    // Se o caracter não existir na numeração romana, a função
        -:   42:    // CharacterValue retorna -1.
        -:   43:
      206:   44:    if(auxiliary_value == -1)
        1:   45:      return -1;
        -:   46:
        -:   47:    else
      205:   48:      sum += auxiliary_value;
        -:   49:
      205:   50:    if (current_char != last_char) {
        -:   51:
        -:   52:      // Condicional para tratar de casos de subtração.
        -:   53:
      143:   54:      if (SubtractionPrecedence(last_char, current_char))
       32:   55:        sum -= (2 * CharacterValue(last_char));
        -:   56:
      143:   57:      last_char = current_char;
      143:   58:      last_char_count = 1;
        -:   59:
        -:   60:    }
        -:   61:
        -:   62:    else {
        -:   63:
       62:   64:      if (last_char_count != 3)
       61:   65:        last_char_count++;
        -:   66:
        -:   67:      // Condicional para tratar de repetições excessivas de um caracter
        -:   68:      // gerando um argumento inválido.
        -:   69:
        -:   70:      else
        1:   71:        return -1;
        -:   72:
        -:   73:    }
        -:   74:
        -:   75:  }
        -:   76:
       39:   77:  return sum;
        -:   78:
        -:   79:}
        -:   80:
        -:   81:/** Função auxiliar para verificar se um dado caracter pode ser repetido na
        -:   82:    numeração romana. Recebe como parâmetro um caracter qualquer. */
        -:   83:
      111:   84:int CanBeRepeated (char current_char) {
        -:   85:
      111:   86:  int char_value = CharacterValue(current_char);
        -:   87:
        -:   88:  // Para que o caracter possa ser repetido, seu valor deve ser uma potência
        -:   89:  // de 10 exata.
        -:   90:
      287:   91:  while (char_value >= 10)
       88:   92:    char_value = char_value/10;
        -:   93:
      111:   94:  if (char_value == 1)
      109:   95:    return 1;
        -:   96:
        -:   97:  else
        2:   98:    return 0;
        -:   99:
        -:  100:}
        -:  101:
        -:  102:/** Função auxiliar para retornar o valor de um dado caracter. */
        -:  103:
     3537:  104:int CharacterValue (char current_char) {
        -:  105:
     3537:  106:  switch (current_char) {
        -:  107:
        -:  108:    case 'I':
     1097:  109:      return 1;
        -:  110:
        -:  111:    case 'V':
      294:  112:      return 5;
        -:  113:
        -:  114:    case 'X':
      970:  115:      return 10;
        -:  116:
        -:  117:    case 'L':
      198:  118:      return 50;
        -:  119:
        -:  120:    case 'C':
      604:  121:      return 100;
        -:  122:
        -:  123:    case 'D':
      115:  124:      return 500;
        -:  125:
        -:  126:    case 'M':
      162:  127:      return 1000;
        -:  128:
        -:  129:    default:
       97:  130:      return -1;
        -:  131:
        -:  132:  }
        -:  133:
        -:  134:}
        -:  135:
        -:  136:/** Função auxiliar para verificar se um dado par de caracteres constitui um caso
        -:  137:    em que o primeiro deve ser subtraido (ao invés de somado) ao valor total.
        -:  138:
        -:  139:   Recebe como parâmetro dois caracteres que são sequenciais. */
        -:  140:
      356:  141:int SubtractionPrecedence (char precedent_char, char current_char) {
        -:  142:
        -:  143:  // Para que a precedência de subtração ocorra, a razão entre o caracter
        -:  144:  // atual e o caracter que o precede deve ser 5 ou 10.
        -:  145:
      681:  146:  if (CharacterValue(current_char)/CharacterValue(precedent_char) == 5 ||
      325:  147:  CharacterValue(current_char)/CharacterValue(precedent_char) == 10)
       77:  148:    return 1;
        -:  149:
        -:  150:  else
      279:  151:    return 0;
        -:  152:
        -:  153:}
        -:  154:
        -:  155:/** Função auxiliar para verificar se os caracteres anteriores a um dado caracter
        -:  156:    constituem um número válido na numeração romana. */
        -:  157:
      214:  158:int ValidPrecedences (char *past_characters, char current_char) {
        -:  159:
        -:  160:  unsigned int iterator;
        -:  161:
        -:  162:  // O primeiro caracter sempre é aceito.
        -:  163:
      214:  164:  if (strlen(past_characters) == 0)
       49:  165:    return 1;
        -:  166:
        -:  167:  // Laço verifica todos os caracteres anteriores ao atual EXCETO o último.
        -:  168:  // Essa implementação é justificada devido à precedência de subtração,
        -:  169:  // uma excessão às regras que só ocorre entre caracteres sequenciais
        -:  170:  // (Ou seja, o último caracter anterior e o atual).
        -:  171:
      522:  172:  for (iterator = 0; iterator < (strlen(past_characters) - 1); iterator++) {
        -:  173:
      363:  174:    if (CharacterValue(past_characters[iterator]) < CharacterValue(current_char))
        4:  175:      return 0;
        -:  176:
        -:  177:    else {
        -:  178:
      359:  179:      if (CharacterValue(past_characters[iterator]) == CharacterValue(current_char)) {
        -:  180:
       48:  181:        if (!CanBeRepeated(current_char))
        1:  182:          return 0;
        -:  183:
        -:  184:        // Condicional especial para tratar de casos em que um caracter
        -:  185:        // é subtraído e depois tenta-se adicioná-lo ao número.
        -:  186:        // (Algo que não pode acontecer).
        -:  187:
       54:  188:        if (SubtractionPrecedence(past_characters[iterator], past_characters[iterator + 1]) &&
        7:  189:        !SubtractionPrecedence(past_characters[(strlen(past_characters) - 1)], current_char))
        1:  190:          return 0;
        -:  191:
        -:  192:      }
        -:  193:
        -:  194:    }
        -:  195:
        -:  196:  }
        -:  197:
        -:  198:  // Condicionais para tratar exclusivamente do último caracter.
        -:  199:
        -:  200:  // Condicional que trata do caso de subtração.
        -:  201:
      159:  202:  if (SubtractionPrecedence(past_characters[iterator], current_char))
       32:  203:    return 1;
        -:  204:
      127:  205:  else if (CharacterValue(past_characters[iterator]) > CharacterValue(current_char))
       63:  206:    return 1;
        -:  207:
       64:  208:  else if (CharacterValue(past_characters[iterator]) == CharacterValue(current_char)) {
        -:  209:
       63:  210:    if (CanBeRepeated(current_char))
       62:  211:      return 1;
        -:  212:
        -:  213:    else
        1:  214:      return 0;
        -:  215:
        -:  216:  }
        -:  217:
        -:  218:  else
        1:  219:    return 0;
        -:  220:
        -:  221:}
