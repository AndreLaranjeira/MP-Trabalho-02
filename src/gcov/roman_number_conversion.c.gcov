        -:    0:Source:roman_number_conversion.c
        -:    0:Graph:roman_number_conversion.gcno
        -:    0:Data:roman_number_conversion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    0:Source is newer than graph
        -:    1:// Função que converte números romanos para números inteiros.
        -:    2:
        -:    3:/**
        -:    4:
        -:    5:  \file
        -:    6:  \brief Arquivo que contém a função para converter números romanos
        -:    7:  em número inteiros, bem como as funções auxiliares neste processo.
        -:    8:
        -:    9:*/
        -:   10:
        -:   11:#include "roman_number_conversion.h"
        -:   12:
        -:   13:/** Função que converte números romanos.
        -:   14:
        -:   15:    Recebe como parâmetro um vetor de caracteres que contém um numeral romano.*/
        -:   16:
       50:   17:int RomanNumberConversion (char *roman_number) {
        -:   18:
       50:   19:  char current_char, last_char = '\0', past_characters[30] = "";
        -:   20:  unsigned int iterator, last_char_count;
       50:   21:  int auxiliary_value, sum = 0;
        -:   22:
        -:   23:  // A função não aceita argumentos com mais de 30 caracteres.
        -:   24:
       50:   25:  if (strlen(roman_number) > 30)
        1:   26:    return -1;
        -:   27:
      253:   28:  for (iterator = 0; iterator < strlen(roman_number); iterator++) {
        -:   29:
        -:   30:    // Os caracteres são processados em caixa alta, evitando problemas.
        -:   31:
      214:   32:    current_char = toupper(roman_number[iterator]);
        -:   33:
      214:   34:    if(!ValidPrecedences(past_characters, current_char))
        8:   35:      return -1;
        -:   36:
        -:   37:    // Armazena-se o caracter atual.
        -:   38:
      206:   39:    past_characters[iterator] = current_char;
        -:   40:
      206:   41:    auxiliary_value = CharacterValue(current_char);
        -:   42:
        -:   43:    // Se o caracter não existir na numeração romana, a função
        -:   44:    // CharacterValue retorna -1.
        -:   45:
      206:   46:    if(auxiliary_value == -1)
        1:   47:      return -1;
        -:   48:
        -:   49:    else
      205:   50:      sum += auxiliary_value;
        -:   51:
      205:   52:    if (current_char != last_char) {
        -:   53:
        -:   54:      // Condicional para tratar de casos de subtração.
        -:   55:
      143:   56:      if (SubtractionPrecedence(last_char, current_char))
       32:   57:        sum -= (2 * CharacterValue(last_char));
        -:   58:
      143:   59:      last_char = current_char;
      143:   60:      last_char_count = 1;
        -:   61:
        -:   62:    }
        -:   63:
        -:   64:    else {
        -:   65:
       62:   66:      if (last_char_count != 3)
       61:   67:        last_char_count++;
        -:   68:
        -:   69:      // Condicional para tratar de repetições excessivas de um caracter
        -:   70:      // gerando um argumento inválido.
        -:   71:
        -:   72:      else
        1:   73:        return -1;
        -:   74:
        -:   75:    }
        -:   76:
        -:   77:  }
        -:   78:
       39:   79:  return sum;
        -:   80:
        -:   81:}
        -:   82:
        -:   83:/** Função auxiliar para verificar se um dado caracter pode ser repetido na
        -:   84:    numeração romana.
        -:   85:
        -:   86:    Recebe como parâmetro um caracter qualquer. */
        -:   87:
      111:   88:int CanBeRepeated (char current_char) {
        -:   89:
      111:   90:  int char_value = CharacterValue(current_char);
        -:   91:
        -:   92:  // Para que o caracter possa ser repetido, seu valor deve ser uma potência
        -:   93:  // de 10 exata.
        -:   94:
      287:   95:  while (char_value >= 10)
       88:   96:    char_value = char_value/10;
        -:   97:
      111:   98:  if (char_value == 1)
      109:   99:    return 1;
        -:  100:
        -:  101:  else
        2:  102:    return 0;
        -:  103:
        -:  104:}
        -:  105:
        -:  106:/** Função auxiliar para retornar o valor de um dado caracter na numeração
        -:  107:    romana.
        -:  108:
        -:  109:    Recebe como parâmetro um caracter qualquer.*/
        -:  110:
     3537:  111:int CharacterValue (char current_char) {
        -:  112:
     3537:  113:  switch (current_char) {
        -:  114:
        -:  115:    case 'I':
     1097:  116:      return 1;
        -:  117:
        -:  118:    case 'V':
      294:  119:      return 5;
        -:  120:
        -:  121:    case 'X':
      970:  122:      return 10;
        -:  123:
        -:  124:    case 'L':
      198:  125:      return 50;
        -:  126:
        -:  127:    case 'C':
      604:  128:      return 100;
        -:  129:
        -:  130:    case 'D':
      115:  131:      return 500;
        -:  132:
        -:  133:    case 'M':
      162:  134:      return 1000;
        -:  135:
        -:  136:    default:
       97:  137:      return -1;
        -:  138:
        -:  139:  }
        -:  140:
        -:  141:}
        -:  142:
        -:  143:/** Função auxiliar para verificar se um dado par de caracteres constitui um caso
        -:  144:    em que o primeiro deve ser subtraido (ao invés de somado) ao valor total.
        -:  145:
        -:  146:    Recebe como parâmetro dois caracteres que são sequenciais. */
        -:  147:
      356:  148:int SubtractionPrecedence (char precedent_char, char current_char) {
        -:  149:
        -:  150:  // Para que a precedência de subtração ocorra, a razão entre o caracter
        -:  151:  // atual e o caracter que o precede deve ser 5 ou 10.
        -:  152:
      681:  153:  if (CharacterValue(current_char)/CharacterValue(precedent_char) == 5 ||
      325:  154:  CharacterValue(current_char)/CharacterValue(precedent_char) == 10)
       77:  155:    return 1;
        -:  156:
        -:  157:  else
      279:  158:    return 0;
        -:  159:
        -:  160:}
        -:  161:
        -:  162:/** Função auxiliar para verificar se os caracteres anteriores em conjunto com o
        -:  163:    caracter não constiuem um argumento inválido na numeração romana. 
        -:  164:
        -:  165:    Recebe como parâmetros um vetor com os caracteres já processados e o
        -:  166:    caracter que está sendo processado.*/
        -:  167:
      214:  168:int ValidPrecedences (char *past_characters, char current_char) {
        -:  169:
        -:  170:  unsigned int iterator;
        -:  171:
        -:  172:  // O primeiro caracter sempre é aceito.
        -:  173:
      214:  174:  if (strlen(past_characters) == 0)
       49:  175:    return 1;
        -:  176:
        -:  177:  // Laço verifica todos os caracteres anteriores ao atual EXCETO o último.
        -:  178:  // Essa implementação é justificada devido à precedência de subtração,
        -:  179:  // uma excessão às regras que só ocorre entre caracteres sequenciais
        -:  180:  // (Ou seja, o último caracter anterior e o atual).
        -:  181:
      522:  182:  for (iterator = 0; iterator < (strlen(past_characters) - 1); iterator++) {
        -:  183:
      363:  184:    if (CharacterValue(past_characters[iterator]) < CharacterValue(current_char))
        4:  185:      return 0;
        -:  186:
        -:  187:    else {
        -:  188:
      359:  189:      if (CharacterValue(past_characters[iterator]) == CharacterValue(current_char)) {
        -:  190:
       48:  191:        if (!CanBeRepeated(current_char))
        1:  192:          return 0;
        -:  193:
        -:  194:        // Condicional especial para tratar de casos em que um caracter
        -:  195:        // é subtraído e depois tenta-se adicioná-lo ao número.
        -:  196:        // (Algo que não pode acontecer).
        -:  197:
       54:  198:        if (SubtractionPrecedence(past_characters[iterator], past_characters[iterator + 1]) &&
        7:  199:        !SubtractionPrecedence(past_characters[(strlen(past_characters) - 1)], current_char))
        1:  200:          return 0;
        -:  201:
        -:  202:      }
        -:  203:
        -:  204:    }
        -:  205:
        -:  206:  }
        -:  207:
        -:  208:  // Condicionais para tratar exclusivamente do último caracter.
        -:  209:
        -:  210:  // Condicional que trata do caso de subtração.
        -:  211:
      159:  212:  if (SubtractionPrecedence(past_characters[iterator], current_char))
       32:  213:    return 1;
        -:  214:
      127:  215:  else if (CharacterValue(past_characters[iterator]) > CharacterValue(current_char))
       63:  216:    return 1;
        -:  217:
       64:  218:  else if (CharacterValue(past_characters[iterator]) == CharacterValue(current_char)) {
        -:  219:
       63:  220:    if (CanBeRepeated(current_char))
       62:  221:      return 1;
        -:  222:
        -:  223:    else
        1:  224:      return 0;
        -:  225:
        -:  226:  }
        -:  227:
        -:  228:  else
        1:  229:    return 0;
        -:  230:
        -:  231:}
